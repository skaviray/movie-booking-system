// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_theaters_and_showtimes_by_movie.sql

package db

import (
	"context"
	"time"
)

const getTheatersAndShowtimesByMovie = `-- name: GetTheatersAndShowtimesByMovie :many
SELECT
  t.id AS theater_id,
  t.name AS theater_name,
  t.location,
  s.id AS screen_id,
  st.id AS showtime_id,
  st.start_time
FROM
  theaters t
JOIN
  screens s ON t.id = s.theater_id
JOIN
  showtimes st ON s.id = st.screen_id
WHERE
  st.movie_id = $1
ORDER BY
  t.name, st.start_time
`

type GetTheatersAndShowtimesByMovieRow struct {
	TheaterID   int64     `json:"theater_id"`
	TheaterName string    `json:"theater_name"`
	Location    int32     `json:"location"`
	ScreenID    int64     `json:"screen_id"`
	ShowtimeID  int64     `json:"showtime_id"`
	StartTime   time.Time `json:"start_time"`
}

func (q *Queries) GetTheatersAndShowtimesByMovie(ctx context.Context, movieID int32) ([]GetTheatersAndShowtimesByMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getTheatersAndShowtimesByMovie, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTheatersAndShowtimesByMovieRow{}
	for rows.Next() {
		var i GetTheatersAndShowtimesByMovieRow
		if err := rows.Scan(
			&i.TheaterID,
			&i.TheaterName,
			&i.Location,
			&i.ScreenID,
			&i.ShowtimeID,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
