// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rentals.sql

package db

import (
	"context"
	"database/sql"
)

const createRental = `-- name: CreateRental :one
INSERT INTO rentals (customer_id, movie_id, date_out, date_returned, rental_fee)
VALUES ($1, $2, COALESCE($3, NOW()), $4, $5)
RETURNING id, customer_id, movie_id, date_out, date_returned, rental_fee
`

type CreateRentalParams struct {
	CustomerID   int32          `json:"customer_id"`
	MovieID      int32          `json:"movie_id"`
	Column3      interface{}    `json:"column_3"`
	DateReturned sql.NullTime   `json:"date_returned"`
	RentalFee    sql.NullString `json:"rental_fee"`
}

func (q *Queries) CreateRental(ctx context.Context, arg CreateRentalParams) (Rental, error) {
	row := q.db.QueryRowContext(ctx, createRental,
		arg.CustomerID,
		arg.MovieID,
		arg.Column3,
		arg.DateReturned,
		arg.RentalFee,
	)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MovieID,
		&i.DateOut,
		&i.DateReturned,
		&i.RentalFee,
	)
	return i, err
}

const deleteRental = `-- name: DeleteRental :exec
DELETE FROM rentals WHERE id = $1
`

func (q *Queries) DeleteRental(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRental, id)
	return err
}

const getRental = `-- name: GetRental :one
SELECT id, customer_id, movie_id, date_out, date_returned, rental_fee FROM rentals WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRental(ctx context.Context, id int64) (Rental, error) {
	row := q.db.QueryRowContext(ctx, getRental, id)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MovieID,
		&i.DateOut,
		&i.DateReturned,
		&i.RentalFee,
	)
	return i, err
}

const listRentals = `-- name: ListRentals :many
SELECT id, customer_id, movie_id, date_out, date_returned, rental_fee FROM rentals
ORDER BY id
`

func (q *Queries) ListRentals(ctx context.Context) ([]Rental, error) {
	rows, err := q.db.QueryContext(ctx, listRentals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rental{}
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.MovieID,
			&i.DateOut,
			&i.DateReturned,
			&i.RentalFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupRental = `-- name: LookupRental :one
SELECT id, customer_id, movie_id, date_out, date_returned, rental_fee FROM rentals
WHERE customer_id = $1 AND movie_id = $2
LIMIT 1
`

type LookupRentalParams struct {
	CustomerID int32 `json:"customer_id"`
	MovieID    int32 `json:"movie_id"`
}

func (q *Queries) LookupRental(ctx context.Context, arg LookupRentalParams) (Rental, error) {
	row := q.db.QueryRowContext(ctx, lookupRental, arg.CustomerID, arg.MovieID)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MovieID,
		&i.DateOut,
		&i.DateReturned,
		&i.RentalFee,
	)
	return i, err
}

const updateRentalReturn = `-- name: UpdateRentalReturn :one

UPDATE rentals
SET date_returned = $2,
    rental_fee = $3
WHERE id = $1
RETURNING id, customer_id, movie_id, date_out, date_returned, rental_fee
`

type UpdateRentalReturnParams struct {
	ID           int64          `json:"id"`
	DateReturned sql.NullTime   `json:"date_returned"`
	RentalFee    sql.NullString `json:"rental_fee"`
}

// LIMIT $1 OFFSET $2;
func (q *Queries) UpdateRentalReturn(ctx context.Context, arg UpdateRentalReturnParams) (Rental, error) {
	row := q.db.QueryRowContext(ctx, updateRentalReturn, arg.ID, arg.DateReturned, arg.RentalFee)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MovieID,
		&i.DateOut,
		&i.DateReturned,
		&i.RentalFee,
	)
	return i, err
}
